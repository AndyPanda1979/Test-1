#***********************************************************************************************************
# 1. На языке Python реализовать алгоритм (функцию) определения четности целого числа, который будет 
# аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций
# def isEven(value):return value%2==0
#***********************************************************************************************************
# Python 3.9.7
import time

def isEven1(value):                     # образец
    return value % 2 == 0


def is_even2(value):
    """
    Через побитовое & сравнение с '1', по факту проверка последнего бита,
    если на выходе 0 -> четное (True)
    если на выходе !0 -> нечетное (False)
    :param value:
    :return: True(if even) or False(if odd)
    Потестировал обе на 1М значений, % работает быстрее, чем &, пока мне сложно это объяснить, надо подробнее понять,
    как реализована % на уровне битов, видимо. Я пока новичок, так далеко в дебри не залезал.
    """
    return value & 1 == 0


# для теста : 1М значений
# 
# timer1 = time.time()
# for a in range(-500000, +500000, 1):
#     isEven1(a)
# time_value_1 = time.time()-timer1
# 
# timer2 = time.time()
# for b in range(-500000, +500000, 1):
#     is_even2(b)
# time_value_2 = time.time()-timer2
# 
# print('Скорость выполнения: value % 2 == 0: ', time_value_1, '; value & 1 == 0: ', time_value_2)

#***********************************************************************************************************

#***********************************************************************************************************
# 2. На языке Python (2.7) реализовать минимум по 2 класса реализовывающих циклический буфер FIFO. 
# Объяснить плюсы и минусы каждой реализации.
#***********************************************************************************************************
# Python 2.7.13
# -*- coding: utf-8 -*-
import time
import collections

"""
Я не стал делать фиксированного размера, т.к. в условии они не обозначены
1 - на обычном list, что очень тормозит работу в момент вытягивания значений в связи с последующим смещением всей очереди
на элемент влево

2 - на collections.deque, который, насколько я понимаю, реализован на C и видимо там может на уровне указателей на начало
списка манипуляции сделаны, но, видимо, смещение не происходит, поэтому из мне на данный момент известных это самый
быстрый вариант.

Еще делал промежуточный вариант, где в рамках экземпляра класса создаются списки например по 50 элементов, если в стек
'набилось' больше 50 элементов, то создается новый список и туда новые данные попадают, а указатели через __dict__
показывают, из какого сейчас списка забирать данные, и куда писать новые. Тогда в теории, сокращается количество смещений
в очереди до емкости одного списка, но громоздко получилось, и по времени оказалось хуже, чем вариант 1, 
поэтому не стал выкладывать.
"""

class FifoStack_v1:                 # На базе обычного list
    def __init__(self):
        self.stack = []

    def push_data(self, value):
        self.stack.append(value)

    def pull_data(self):
        if not self.stack:
            print 'Stack is Empty.'
            return None
        return self.stack.pop(0)


class FifoStack_v2:                # На базе collections.deque
    def __init__(self):
        self.stack = collections.deque()

    def push_data(self, value):
        self.stack.append(value)

    def pull_data(self):
        if not self.stack:
            print 'Stack is Empty.'
            return None
        return self.stack.popleft()

# Для теста: очередь 100К элементов, до 10К идет только запись, потом до конца цикла чередуется push_data и pull_data


# s1 = FifoStack_v1()
# test_time_1 = time.time()
# for i in range(1, 100000):
#     s1.push_data(i)
#     if i > 10000:
#         s1.pull_data()
# print'list : ', time.time() - test_time_1

# s2 = FifoStack_v2()
# test_time_2 = time.time()
# for i in range(1, 100000):
#      s2.push_data(i)
#      if i > 10000:
#          s2.pull_data()
# print'deque : ', time.time() - test_time_2
#***********************************************************************************************************

#***********************************************************************************************************
# 3. На языке Python реализовать функцию, которая быстрее всего (по процессорным тикам) отсортирует данный ей 
# массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). 
# Объяснить почему вы считаете, что функция соответствует заданным критериям.
#***********************************************************************************************************
# Python 3.9.7
import random
import time

def sort_array(value):
    """
    Использован алгоритм Хоара, несмотря на код Python, работает на равне с родным sort(), который, как я понимаю, реализован на C
    Изначально благодаря разбиению на блоки и уменьшая размер исходного массива, удается сократить кол-во итераций.
    Но, признаюсь честно, мне сложно это выразить в математической форме, я на текущий момент знаю, какая скорость может
    буть достигнута при применении этого алгоритма, и понимаю, как он работает и где может выигрывать у сортировки вставками,
    но почему сложность равна в среднем N* именно на log2N, я пока в голове не уложил у себя :)
    """
    if len(value) > 1:
        separator = value[random.randint(0, len(value)-1)]
        low_v = [i for i in value if i < separator]
        eq_v = [i for i in value if i == separator]
        hi_v = [i for i in value if i > separator]
        value = sort_array(low_v) + eq_v + sort_array(hi_v)
    return value


# Для теста, на вход массив из 1М случайных в диапазоне (0~1М) элементов.
# Сравниваю со встроенным list.sort() по времени выполнения

# a = []
# for k in range(0, 1000000):
#     a.append(random.randint(1, 1000000))
# b = a[:]
# 
# timer1 = time.time()
# a.sort()
# timer2 = time.time()
# b = sort_array(b)
# 
# print('сортировка .sort(): ', time.time()-timer1, '; сортировка Хоара : ', time.time()-timer2)
#***********************************************************************************************************
